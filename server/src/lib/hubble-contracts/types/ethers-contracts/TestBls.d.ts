/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  CallOverrides
} from "@ethersproject/contracts";
import {BytesLike} from "@ethersproject/bytes";
import {Listener, Provider} from "@ethersproject/providers";
import {FunctionFragment, EventFragment, Result} from "@ethersproject/abi";

interface TestBlsInterface extends ethers.utils.Interface {
  functions: {
    "expandMsg(bytes32,bytes)": FunctionFragment;
    "hashToField(bytes32,bytes)": FunctionFragment;
    "hashToPoint(bytes32,bytes)": FunctionFragment;
    "hashToPointGasCost(bytes32,bytes)": FunctionFragment;
    "isOnCurveG1(uint256[2])": FunctionFragment;
    "isOnCurveG1GasCost(uint256[2])": FunctionFragment;
    "isOnCurveG2(uint256[4])": FunctionFragment;
    "isOnCurveG2GasCost(uint256[4])": FunctionFragment;
    "mapToPoint(uint256)": FunctionFragment;
    "verifyMultiple(uint256[2],uint256[4][],uint256[2][])": FunctionFragment;
    "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])": FunctionFragment;
    "verifySingle(uint256[2],uint256[4],uint256[2])": FunctionFragment;
    "verifySingleGasCost(uint256[2],uint256[4],uint256[2])": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "expandMsg",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hashToField",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hashToPoint",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hashToPointGasCost",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "isOnCurveG1",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "isOnCurveG1GasCost",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "isOnCurveG2",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "isOnCurveG2GasCost",
    values: [BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "mapToPoint",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyMultiple",
    values: [BigNumberish[], BigNumberish[][], BigNumberish[][]]
  ): string;
  encodeFunctionData(
    functionFragment: "verifyMultipleGasCost",
    values: [BigNumberish[], BigNumberish[][], BigNumberish[][]]
  ): string;
  encodeFunctionData(
    functionFragment: "verifySingle",
    values: [BigNumberish[], BigNumberish[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "verifySingleGasCost",
    values: [BigNumberish[], BigNumberish[], BigNumberish[]]
  ): string;

  decodeFunctionResult(functionFragment: "expandMsg", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hashToField",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hashToPoint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hashToPointGasCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOnCurveG1",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOnCurveG1GasCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOnCurveG2",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isOnCurveG2GasCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mapToPoint", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "verifyMultiple",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyMultipleGasCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifySingle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifySingleGasCost",
    data: BytesLike
  ): Result;

  events: {};
}

export class TestBls extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: TestBlsInterface;

  functions: {
    expandMsg(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "expandMsg(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    hashToField(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
    }>;

    "hashToField(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber[];
    }>;

    hashToPoint(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      p: BigNumber[];
      0: BigNumber[];
    }>;

    "hashToPoint(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<{
      p: BigNumber[];
      0: BigNumber[];
    }>;

    hashToPointGasCost(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "hashToPointGasCost(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isOnCurveG1(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isOnCurveG1(uint256[2])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isOnCurveG1GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "isOnCurveG1GasCost(uint256[2])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    isOnCurveG2(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    "isOnCurveG2(uint256[4])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    isOnCurveG2GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "isOnCurveG2GasCost(uint256[4])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    mapToPoint(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      p: BigNumber[];
      0: BigNumber[];
    }>;

    "mapToPoint(uint256)"(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      p: BigNumber[];
      0: BigNumber[];
    }>;

    verifyMultiple(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    "verifyMultiple(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    verifyMultipleGasCost(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    verifySingle(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    "verifySingle(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    verifySingleGasCost(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    "verifySingleGasCost(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  expandMsg(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  "expandMsg(bytes32,bytes)"(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  hashToField(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  "hashToField(bytes32,bytes)"(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  hashToPoint(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  "hashToPoint(bytes32,bytes)"(
    domain: BytesLike,
    message: BytesLike,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  hashToPointGasCost(
    domain: BytesLike,
    message: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "hashToPointGasCost(bytes32,bytes)"(
    domain: BytesLike,
    message: BytesLike,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isOnCurveG1(
    point: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isOnCurveG1(uint256[2])"(
    point: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOnCurveG1GasCost(
    point: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "isOnCurveG1GasCost(uint256[2])"(
    point: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  isOnCurveG2(
    point: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  "isOnCurveG2(uint256[4])"(
    point: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  isOnCurveG2GasCost(
    point: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "isOnCurveG2GasCost(uint256[4])"(
    point: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  mapToPoint(e: BigNumberish, overrides?: CallOverrides): Promise<BigNumber[]>;

  "mapToPoint(uint256)"(
    e: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  verifyMultiple(
    signature: BigNumberish[],
    pubkeys: BigNumberish[][],
    messages: BigNumberish[][],
    overrides?: CallOverrides
  ): Promise<{
    0: boolean;
    1: boolean;
  }>;

  "verifyMultiple(uint256[2],uint256[4][],uint256[2][])"(
    signature: BigNumberish[],
    pubkeys: BigNumberish[][],
    messages: BigNumberish[][],
    overrides?: CallOverrides
  ): Promise<{
    0: boolean;
    1: boolean;
  }>;

  verifyMultipleGasCost(
    signature: BigNumberish[],
    pubkeys: BigNumberish[][],
    messages: BigNumberish[][],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])"(
    signature: BigNumberish[],
    pubkeys: BigNumberish[][],
    messages: BigNumberish[][],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  verifySingle(
    signature: BigNumberish[],
    pubkey: BigNumberish[],
    message: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<{
    0: boolean;
    1: boolean;
  }>;

  "verifySingle(uint256[2],uint256[4],uint256[2])"(
    signature: BigNumberish[],
    pubkey: BigNumberish[],
    message: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<{
    0: boolean;
    1: boolean;
  }>;

  verifySingleGasCost(
    signature: BigNumberish[],
    pubkey: BigNumberish[],
    message: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  "verifySingleGasCost(uint256[2],uint256[4],uint256[2])"(
    signature: BigNumberish[],
    pubkey: BigNumberish[],
    message: BigNumberish[],
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    expandMsg(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    "expandMsg(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    hashToField(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    "hashToField(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    hashToPoint(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    "hashToPoint(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    hashToPointGasCost(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashToPointGasCost(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOnCurveG1(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isOnCurveG1(uint256[2])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOnCurveG1GasCost(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isOnCurveG1GasCost(uint256[2])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOnCurveG2(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    "isOnCurveG2(uint256[4])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    isOnCurveG2GasCost(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isOnCurveG2GasCost(uint256[4])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mapToPoint(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    "mapToPoint(uint256)"(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    verifyMultiple(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    "verifyMultiple(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    verifyMultipleGasCost(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifySingle(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    "verifySingle(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
      1: boolean;
    }>;

    verifySingleGasCost(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "verifySingleGasCost(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {};

  estimateGas: {
    expandMsg(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "expandMsg(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashToField(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashToField(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashToPoint(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "hashToPoint(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hashToPointGasCost(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    "hashToPointGasCost(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<BigNumber>;

    isOnCurveG1(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isOnCurveG1(uint256[2])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOnCurveG1GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "isOnCurveG1GasCost(uint256[2])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    isOnCurveG2(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "isOnCurveG2(uint256[4])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isOnCurveG2GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "isOnCurveG2GasCost(uint256[4])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    mapToPoint(e: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "mapToPoint(uint256)"(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyMultiple(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "verifyMultiple(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifyMultipleGasCost(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<BigNumber>;

    verifySingle(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "verifySingle(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    verifySingleGasCost(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;

    "verifySingleGasCost(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    expandMsg(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "expandMsg(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashToField(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hashToField(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashToPoint(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "hashToPoint(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hashToPointGasCost(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "hashToPointGasCost(bytes32,bytes)"(
      domain: BytesLike,
      message: BytesLike,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isOnCurveG1(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isOnCurveG1(uint256[2])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOnCurveG1GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "isOnCurveG1GasCost(uint256[2])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    isOnCurveG2(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "isOnCurveG2(uint256[4])"(
      point: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isOnCurveG2GasCost(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "isOnCurveG2GasCost(uint256[4])"(
      point: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    mapToPoint(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "mapToPoint(uint256)"(
      e: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyMultiple(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "verifyMultiple(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifyMultipleGasCost(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "verifyMultipleGasCost(uint256[2],uint256[4][],uint256[2][])"(
      signature: BigNumberish[],
      pubkeys: BigNumberish[][],
      messages: BigNumberish[][],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    verifySingle(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "verifySingle(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    verifySingleGasCost(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    "verifySingleGasCost(uint256[2],uint256[4],uint256[2])"(
      signature: BigNumberish[],
      pubkey: BigNumberish[],
      message: BigNumberish[],
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
